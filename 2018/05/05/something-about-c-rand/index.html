<!doctype html>
<html lang="zh-cn">

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css" integrity="sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4"
    crossorigin="anonymous">

  <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">


  <style>
    .m-margin {
      margin-top: 2%;
    }

    p {
      font-size: 1.1em;
      line-height: 1.6;
    }

    h2 {
      font-size: 2em;
    }

    body {
      font-family: "Microsoft YaHei", "lucida grande", "lucida sans unicode", lucida, helvetica, "Hiragino Sans GB", "WenQuanYi Micro Hei", sans-serif;
    }
  </style>
  <title>Notes</title>
</head>

<body>
  <!-- As a link -->
  <nav class="navbar navbar-light bg-light">
    <a class="navbar-brand" href="/">Notes</a>
  </nav>
  <div class="container m-margin">
    <h3>
    Something About C rand
</h3>

<hr style="height:1.2px;color:#C0C0C0;background-color:#C0C0C0; rounded" />


<h3>Introduction</h3>
<hr>
<p>see <a href="http://en.cppreference.com/w/c/numeric/random/rand" target="_blank" rel="noopener">rand</a> in cppreference.com</p>
<h4>Syntax</h4>
<pre><code class="language-c">int rand(); // Defined in header &lt;stdlib.h&gt;
</code></pre>
<h4>Return Value</h4>
<p>Returns a pseudo-random integer value between ​0​ and <code>RAND_MAX</code> (0 and <code>RAND_MAX</code> included).</p>
<h4>Remarks</h4>
<p>srand() seeds the pseudo-random number generator used by rand(). If rand() is used before any calls to srand(), rand() behaves as if it was seeded with srand(1). Each time rand() is seeded with srand(), it must produce the same sequence of values.</p>
<p><code>rand()</code> is <strong>not guaranteed to be thread-safe</strong>.</p>
<h4>Example</h4>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

int main(void)
{
    srand(time(NULL)); // use current time as seed for random generator
    int random_variable = rand();
    printf(&quot;Random value on [0,%d]: %d\n&quot;, RAND_MAX, random_variable);
}
</code></pre>
<h4>A possible implementation</h4>
<pre><code class="language-c">#define RAND_MAX 32767
unsigned long int next = 1;

int _rand(void) // RAND_MAX assumed to be 32767
{
    next = next * 1103515245 + 12345;
    return (unsigned int)(next/65536) % 32768;
}

void _srand(unsigned int seed)
{
    next = seed;
}
</code></pre>
<h3>Thread-safe rand</h3>
<hr>
<p>POSIX offered a thread-safe version of rand called <code>rand_r()</code></p>
<p>In windows, there is <code>rand_s()</code>, see <a href="https://msdn.microsoft.com/en-us/library/sxtz2fa8.aspx" target="_blank" rel="noopener">this</a>.</p>
<p>An example</p>
<pre><code class="language-c">#define _CRT_RAND_S  

#include &lt;stdlib.h&gt;  
#include &lt;stdio.h&gt;  
#include &lt;limits.h&gt;  

int main()
{
	unsigned int number;
	err = rand_s(&amp;number);
	if (err != 0)  
		printf_s(&quot;The rand_s function failed!\n&quot;);  
	printf_s(&quot;Random value on [0,%u]: %u\n&quot;, UINT_MAX, number);
	return 0;  
}
</code></pre>
<h4>Performance</h4>
<pre><code class="language-c">// =============================================
// check performance of rand and rand_s
// =============================================
n = (int)1e8;

// rand
start = clock();
#pragma omp parallel for num_threads(4)
for(i = 0; i &lt; n; i++)
	rand();
end = clock();
printf(&quot;Func: rand Iteration: %.E Elapsed cpu time: %f\n&quot;,
	(double)n, (double)(end-start)/CLOCKS_PER_SEC);

// rand_s
start = clock();
#pragma omp parallel for num_threads(4)
for(i = 0; i &lt; n; i++)
	rand_s(&amp;t);
end = clock();
printf(&quot;Func: rand_s Iteration: %.E Elapsed cpu time: %f\n&quot;,
	(double)n, (double)(end-start)/CLOCKS_PER_SEC);

/* Output
Func: rand Iteration: 1E+08 Elapsed cpu time: 0.415000
Func: rand_s Iteration: 1E+08 Elapsed cpu time: 5.758000
*/
</code></pre>
<p>The results show that <code>rand_s()</code> is much slower than <code>rand()</code>.
In my opinion, there are mainly two reasons:</p>
<ul>
<li><code>rand_s()</code> may use some synchronization techniques to make sure that it's thread-safe</li>
<li><code>rand_s()</code> generates <em>cryptographically secure random numbers</em>, so it's much more complicated than <code>rand()</code></li>
</ul>
<h3><code>rand()</code> in multiple threads</h3>
<hr>
<h4>No after effect</h4>
<p>rand() in a thread won't affect rand() in other threads.</p>
<p><strong>Test</strong></p>
<ul>
<li>OpenMP Thread</li>
</ul>
<pre><code class="language-c">srand(1);
wait = 1;
#pragma omp parallel num_threads(2) private(i, tid) shared(wait) default(shared)
{
	tid = omp_get_thread_num();
	if(tid == 0){
		printf(&quot;[OpenMP Thread %d]: generate number %d\n&quot;, tid, rand());
		wait = 0;
	}
	else{
		while(wait);
		printf(&quot;[OpenMP Thread %d]: generate number %d\n&quot;, tid, rand());
	}
}
/* Output
[OpenMP Thread] 0: generate number 41
[OpenMP Thread] 1: generate number 41
*/
</code></pre>
<ul>
<li>Windows Thread</li>
</ul>
<pre><code class="language-c">DWORD WINAPI MyThreadFunc(LPVOID lpParam)
{
	printf(&quot;[Windows Thread] generate number %d\n&quot;, rand());
	return 0;
}
int main()
{
	HANDLE hThreadArray[MAX_THREADS];
	for(i = 0; i &lt; MAX_THREADS; i++)
		hThreadArray[i] = CreateThread(0, 0, MyThreadFunc, 0, 0, &amp;t);
	WaitForMultipleObjects(MAX_THREADS, hThreadArray, 1, INFINITE);
	for(i = 0; i &lt; MAX_THREADS; i++)
		CloseHandle(hThreadArray[i]);
}
/* Output
[Windows Thread] generate number 41
[Windows Thread] generate number 41
*/
</code></pre>
<h4>Randomness</h4>
<p>Every thread sets a different seed, such as <code>time(0) + thread_id</code></p>
<p><strong>Single thread</strong></p>
<p>[Thread 0]: <code>srand(time(0))</code> -&gt; <code>rand()</code> -&gt; <code>rand()</code> -&gt; ... -&gt; <code>rand()</code></p>
<p><strong>Multiple threads</strong></p>
<p>[Thread 0]: <code>srand(time(0) + 0)</code> -&gt; <code>rand()</code> -&gt; <code>rand()</code> -&gt; ... -&gt; <code>rand()</code></p>
<p>[Thread 1]: <code>srand(time(0) + 1)</code> -&gt; <code>rand()</code> -&gt; <code>rand()</code> -&gt; ... -&gt; <code>rand()</code></p>
<p>...</p>
<p>[Thread n]: <code>srand(time(0) + n)</code> -&gt; <code>rand()</code> -&gt; <code>rand()</code> -&gt; ... -&gt; <code>rand()</code></p>
<p><strong>Code</strong>:</p>
<pre><code class="language-c">// =============================================
// check randomness difference
// =============================================
n = (int)1e7;
m = 100;
// Without omp
var = 0;
for(i = 0; i &lt; m; i++){
    pi_t = mc_pi(n);
    var += (pi_t - PI) * (pi_t - PI);
}
printf(&quot;Without OMP Variance: %lf\n&quot;, var);
// With OMP
var_omp = 0;
for(i = 0; i &lt; m; i++){
    pi_t = mc_pi_omp(n);
    var_omp += (pi_t - PI) * (pi_t - PI);
}
printf(&quot;With OMP Variance: %lf\n&quot;, var_omp);

/* Output
Without OMP Variance: 0.000025
With OMP Variance: 0.000028
*/
</code></pre>
<p>The results show that the randomness of two versions is almost the same, but <code>rand()</code> in single thread is a little better.</p>

  </div>

  </div>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

  <script>

    $(document).ready(function () {
      $("img").addClass("img-fluid");
    });

    hljs.initHighlightingOnLoad();

  </script>

</body>

</html>